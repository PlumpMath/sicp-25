;;; for appy-generic see data-directed programming or generic operators

(defun add (x y) (apply-generic 'add x y))
(defun sub (x y) (apply-generic 'sub x y))
(defun mul (x y) (apply-generic 'mul x y))
(defun div (x y) (apply-generic 'div x y))

(defun install-cl-number-package ()
  (labels ((tag (x)
             (attach-tag 'cl-number x)))
    (put 'add '(cl-number cl-number)
         (lambda (x y) (tag (+ x y))))
    (put 'sub '(cl-number cl-number)
         (lambda (x y) (tag (- x y))))
    (put 'mul '(cl-number cl-number)
         (lambda (x y) (tag (* x y))))
    (put 'div (cl-number cl-number)
         (lambda (x y) (tag (/ x y))))
    (put 'make 'cl-number
         (lambda (x) (tag x)))
    'done))
(defun make-cl-number (n)
  (funcall (get 'make 'cl-number) n))

(defun install-rational-package ()
  (labels
      ((numer (x)
         (car x))
       (denom (x)
         (cdr x))
       (make-rat (n d)
         (let ((g (gcd n d)))
           (cons (/ n g) (/ d g))))
       (add-rat (x y)
         (make-rat (+ (* (numer x) (denom y))
                      (* (numer y) (denom x)))
                   (* (denom x) (denom y))))
       (sub-rat (x y)
         (make-rat (- (* (numer x) (denom y))
                      (* (numer y) (denom x)))
                   (* (denom x) (denom y))))
       (mul-rat (x y)
         (make-rat (* (numer x) (numer y))
                   (* (denom x) (denom y))))
       (div-rat (x y)
         (make-rat (* (numer x) (denom y))
                   (* (denom x) (numer y))))
       (tag (x)
         (attach-tag 'rational x))
       (put 'add '(rational rational)
            (lambda (x y) (tag (add-rat x y))))
       (put 'sub '(rational rational)
            (lambda (x y) (tag (sub-rat x y))))
       (put 'mul '(rational rational)
            (lambda (x y) (tag (mul-rat x y))))
       (put 'div '(rational rational)
            (lambda (x y) (tag (div-rat x y))))
       (put 'make 'rational
            (lambda (n d) (tag (make-rat n d))))
       'done)))
(defun make-rational (n d)
  (funcall (get 'make 'rational) n d))

(defun install-complex-package ()
  (labels
      ((make-from-real-imag (x y)
         (funcall (get 'make-from-real-imag 'rectangular) x y))
       (make-from-mag-ang (r a)
         (funcall (get 'make-from-mag-ang 'polar) r a))
       (add-complex (a b)
         (make-from-real-imag (+ (real-part a) (real-part b))
                              (+ (imag-part a) (imag-part b))))
       (sub-complex (a b)
         (make-from-real-imag (- (real-part a) (real-part b))
                              (- (imag-part a) (imag-part b))))
       (mul-complex (a b)
         (make-from-mag-ang (* (magnitude a) (magnitude b))
                            (+ (angle a) (angle b))))
       (div-complex (a b)
         (make-from-mag-ang (/ (magnitude a) (magnitude b))
                            (- (angle a) (angle b))))
       (tag (x)
         (attach-tag 'complex x)))
    (put 'add '(complex complex)
         (lambda (a b) (tag (add-complex a b))))
    (put 'sub '(complex complex)
         (lambda (a b) (tag (sub-complex a b))))
    (put 'mul '(complex complex)
         (lambda (a b) (tag (mul-complex a b))))
    (put 'div '(complex complex)
         (lambda (a b) (tag (div-complex a b))))
    (put 'make-from-real-imag 'complex
         (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'comlex
         (lambda (r a) (tag (make-from-mag-ang r a))))
    'done))

(defun make-complex-from-real-imag (x y)
  (funcall (get 'make-from-real-imag 'complex) x y))
(defun make-complex-from-mag-ang (r a)
  (funcall (get 'make-from-mag-ang 'complex) r a))
